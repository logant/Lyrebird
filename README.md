![Image](https://raw.github.com/logant/Lyrebird/master/LyrebirdCommon/images/Lyrebird-Logo.png)
========
## Description ##
Explorations for a presumptive version 2 of Lyrebird. The project has been on the backburner for a while, and there are plenty of services and projects popping up over the years since Lyrebird started that may be able to do what this is trying to do with at least more flexibility. Lyrebird contains plugins for Audoesk Revit and McNeel's Rhino plugin Grasshopper that allow information to be exchanged primarily Grasshopper to Revit or Revit to Grasshopper.

As it currently stands the general concept between this version and the original Lyrebird are not very different. A Revit addin will start a WCF service through which the Grasshopper components will connect. The communication pipeline is the same, but how the two applications talk to each other will be somewhat different. It's very much a master/slave type setup, with all actions being defined on the Grasshopper side and carried out by Revit. The setup was largely to make it easier to add additional functionality to Lyrebird without having to add functionality in multiple locations. 

Revit will open the WCF service and then creates an ExternalEvent that can be triggered from the service. There's currently a single method that the WCF service can do called LbAction. This takes a dictionary<string,object> as input and outputs a dictionary<string,object> so that the inputs and outputs can be catered to whatever the grasshopper component needs. The LbAction method witll then call the LbHandler, an ExternalEventHandler for Revit that makes sure all actions take place within the API context. This component then runs whatever action the Grasshopper component sending information has told it to run. This setup has advantages over the original lyrebird in that it's no longer relying on the OnIdling event, a known resource hog, and it's generic and extensible to easily provide more functionality.

The Grasshopper components are always in two parts (at least). The first part is the GHComponent that creates the Grasshopper component. This class is where you setup the inputs/outputs for Grasshopper and initiates the connection to Revit. The other part is the ILyrebirdAction that contains all of the code to tell Revit what to do. This requires the project reference the Revit API dll's, but the Revit side LbHandler will load the references into the LyrebirdAction class before it tries to run the code, so no need to keep local copies of the dll's.

Currently the project to look at in this repo is CameraSync. This contains two GHComponents to get/set Revit camera information, and two paired actions that actually do the work of getting/setting the Revit camera. This shows that you really only need to create one GHA file to add the necessary functionality to both Grasshopper and Revit, minimizing the places where things can go wrong.

## Contributors ##
* [Timothy Logan](https://github.com/logant): Started the project, main developer
